// <auto-generated/>
#nullable enable
namespace Pochteca;

/// <summary>
/// Computes billable units for a completed request.
/// </summary>
public interface IUnitCalculator
{
    /// <summary>
    /// Calculates units for the specified request.
    /// </summary>
    /// <param name="request">The request information.</param>
    /// <returns>The computed units result.</returns>
    UnitsResult Calculate(RequestInfo request);
}

/// <summary>
/// Resolves the best matching unit rule for a given request.
/// </summary>
public interface IUnitRuleProvider
{
    /// <summary>
    /// Resolves a unit rule for the specified request.
    /// </summary>
    /// <param name="request">The request information.</param>
    /// <returns>The best matching rule, or <c>null</c> if none found.</returns>
    UnitRule? ResolveRule(RequestInfo request);
}

/// <summary>
/// Persists or enqueues usage events in a durable way.
/// Implementations should be safe for at-least-once delivery semantics.
/// </summary>
public interface IUsageSink
{
    /// <summary>
    /// Writes a batch of usage events to durable storage or a queue.
    /// </summary>
    /// <param name="batch">The batch of events.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    Task WriteAsync(IReadOnlyList<UsageEvent> batch, CancellationToken cancellationToken = default);
}

/// <summary>
/// Convenience facade that performs deduplication, calculates units, and writes events.
/// </summary>
public interface IUsageMeter
{
    /// <summary>
    /// Attempts to record a single usage event. Returns the existing event if duplicate, or the new event if recorded.
    /// </summary>
    /// <param name="payer">The party financially responsible for this usage.</param>
    /// <param name="request">The request information.</param>
    /// <param name="idempotencyKey">Optional idempotency key for deduplication.</param>
    /// <param name="requestId">The per-request correlation identifier.</param>
    /// <param name="billable">Indicates whether this event is billable (default = true).</param>
    /// <param name="subject">Optional subject of the work.</param>
    /// <param name="sponsor">Optional reseller or partner.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>The newly recorded event, or the prior event if a duplicate, or <c>null</c> if suppressed.</returns>
    Task<UsageEvent?> TryRecordAsync(
        TenantId payer,
        RequestInfo request,
        IdempotencyKey? idempotencyKey,
        RequestId requestId,
        bool billable = true,
        TenantId? subject = null,
        string? sponsor = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Attempts to record a batch of usage events with a single sink write.
    /// Duplicates will return the prior event where retrievable.
    /// </summary>
    /// <param name="payer">The party financially responsible for these usages.</param>
    /// <param name="batch">The batch of usage items to record.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>The list of recorded or prior events (order corresponds to input).</returns>
    Task<IReadOnlyList<UsageEvent>> TryRecordBatchAsync(
        TenantId payer,
        IReadOnlyList<UsageBatchItem> batch,
        CancellationToken cancellationToken = default);
}

/// <summary>
/// At-least-once deduplication store, scoped by tenant and endpoint.
/// </summary>
public interface IUsageDedupeStore
{
    /// <summary>
    /// Attempts to stamp a unique combination for deduplication.
    /// </summary>
    /// <param name="tenant">The tenant (payer) identifier.</param>
    /// <param name="endpoint">The endpoint key.</param>
    /// <param name="requestId">The per-request correlation identifier.</param>
    /// <param name="idempotencyKey">Optional idempotency key.</param>
    /// <param name="timeToLive">The time-to-live window for the dedupe entry.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns><c>true</c> if the stamp is new; otherwise, <c>false</c> if a duplicate.</returns>
    Task<bool> TryStampAsync(
        TenantId tenant,
        EndpointKey endpoint,
        RequestId requestId,
        IdempotencyKey? idempotencyKey,
        TimeSpan timeToLive,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Attempts to retrieve the previously recorded event for the specified combination.
    /// </summary>
    /// <param name="tenant">The tenant (payer) identifier.</param>
    /// <param name="endpoint">The endpoint key.</param>
    /// <param name="requestId">The per-request correlation identifier.</param>
    /// <param name="idempotencyKey">Optional idempotency key.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>The previously recorded event if found; otherwise, <c>null</c>.</returns>
    Task<UsageEvent?> TryGetAsync(
        TenantId tenant,
        EndpointKey endpoint,
        RequestId requestId,
        IdempotencyKey? idempotencyKey,
        CancellationToken cancellationToken = default);
}

/// <summary>
/// Clock abstraction for testability.
/// </summary>
public interface IClock
{
    /// <summary>
    /// Gets the current UTC timestamp.
    /// </summary>
    DateTimeOffset UtcNow { get; }
}
